\documentclass[10pt]{book}
\usepackage[width=5.5in,height=8.5in,hmarginratio=3:2,vmarginratio=1:1]{geometry}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
%\usepackage{listings}

\begin{document}
	\title{Динамические формы: Исчерпывающее руководство для новичков}
	\author{Кирилл Кривошеев}

	\maketitle
	\tableofcontents
	\mainmatter
	
	\chapter{Введение}
	
	\section{Что такое программа}
	
    \subsection{Основные концепции}
        Предугадав тенденции развития функциональных языков программирования, динамический язык взял за основу концепцию именно данного типа языков, по факту в динамическом языке отсутствуют переменные, константы и остальные нагромождения ООП, все реализуется через функции или через чистые функции. Хотя результатом функций и являются объекты с которыми происходит взаимодействие, но по мнению автора(ов) при разработке программ на динамическом языке стоит придерживаться функциональных подходов программирования. Это позволит полноценно оценить все тонкости разработки.
        Константы и строки в динамическом языке являются чистыми функциями в результате возвращающими литеральное значение самих себя.
        
        В частности чистая функция this или __this__  возвращает объект над которым производится вычисление функции
        А функция «text» вернет строковый литерал соответствующий самому себе.
        
        Вышесказанные концепции очень важны для дальнейшего понимания функционального ядра динамического языка.

	\section{Запуск динамических команд}
	Одним из первых вызовов, который бросает динамический язык начинающему разработчику, является необходимость настройки рабочего окружения HP Service Manager для редактирования шаблонов динамических форм. Однако, благодаря мощным возможностям динамического языка, сделать первые шаги в разработке можно гораздо проще: достаточно открыть шаблон обращения <<Исполнятор>> в dev-среде портала <<Лицо ДРУГа>>. Это простая динамическая форма, состящая всего из двух полей: <<Команда>> и <<Результат>>.
	
	\section{Первая программа}
	
	По давней традиции, первая программа, которую начинающий разработчик пишет на новом языке, является <<Hello, world!>>. На динамическом языке она выглядит так:
	\begin{verbatim}
	>>> setValue([Hello, world!],[result])
	\end{verbatim}
	
	Для выполнения программы введите ее в поле <<Команда>> и переставьте курсор в поле <<Результат>>. В итоге, в поле <<Результат>> вы увидите текст:
	
	\begin{verbatim}
	Hello, World!
	\end{verbatim}
	
	Поздравляем! Вы сделали первый шаг на безумно интересном пути к освоению могучих возможностей создани интерактивных форм, который дает вам Динамический язык.
	Это пример команды {\bf setValue}, которая устанавливает значение, указанное первым аргументом в квадратных скобках в поле, указанное во втором аргументе.
	
	Здесь и далее, все команды, которые вводятся в поле <<Команда>> будут предваряться символами 	\begin{verbatim}
	>>>
	\end{verbatim}	За которыми следует результат выполнения в поле <<Результат>>
	
	\section{Чувствительность к регистру}
	
	Динамческий язык нечувствителен к регистру. Это означает, что программы:
	
	\begin{verbatim}
	>>> setvalue([Hello, world!],[result])
	\end{verbatim}
	
	и
	
	\begin{verbatim}
	>>> setvalue([Hello, world!],[result])
	\end{verbatim}
	
	и даже
	
	\begin{verbatim}
	>>> sEtVaLuE([Hello, world!],[result])
	\end{verbatim}
	
	C точки зрения интерпретатора динамического языка являются индентичными и произведут одинаковый результат. И несмотря на то, что последний пример выглядит, безусловно, наиболее круто, в примерах к книге мы будем придерживаться так называемого CamelCase, так как он наиболее удобочитаем:
	
	\begin{verbatim}
	>>> setValue([Hello, world!],[result])
	\end{verbatim}
	
	\section{Арифметические функции}
	
	Перейдем от <<Hello, world!>> к арифметике. Как и любой, уважающий себя язык программирования, динамический язык предоставляет возможность работы с основными арифметическими операциями, а именно {\bf plus}, {\bf minus} и {\bf mul} для сложения, вычитания и умножения, а также {\bf div} для деления:
	
	\begin{verbatim}
	>>> setValue([plus([68],[1])],[result])
	69
	>>> setValue([minus([69],[1])],[result])
	68
	>>> setValue([mul([6],[7])],[result])
	42
	>>> setValue([div([84],[2])],[result])
	42
	\end{verbatim}
	
	На самом деле, указанные функции обладают гораздо большим набором возможностей, но для первого знакомства этого будет достаточно. 
				
	\section{Упражнения}
	
	Откройте шаблон <<Исполнятор>> и решите следующие задачи:
	
	\begin{enumerate}
		\item Сколько будет в градусах Цельсия температура в 69 Фаренгейт?
		
		\item Сколько спринтов потребуется для вывода в промышленную эксплуатацию шаблона <<Совместная поездка>> если каждый спринт исправляется 6 багов, и обнаруживается 4 новых?
	\end{enumerate}
	
	
	% Структура программы =====================================================================
	\chapter{Структура программы}
	
	\section{Значения и типы}
	
	\section{Идентификаторы}
	
	\section{Возвращаемые значения}
	
	\section{Порядок выполнения}
    \label{sec:execrules} 
        В основу выполнения команд динамического языка лежит очень важная и простая концепция - выполнение функций должно происходить по слоям из самого глубокого вложенной функции к корневому элементу, при этом функция не может быть выполнена, пока не выполнены все ее дочерние элементы.
        
        Пример
        
        Время шло и бизнес требования развития динамических форм внесли свои коррективы, а именно потребовалась реализация асинхронных методом, каждый из которых мог бы выполняться в отдельном потоке или эмулировать выполнение, что потребовало серьезных изменений в структуре разбора и выполнения функций.
        
        Итак поэтапно разберем последовательность действий происходящих при парсинге команд:
        \begin{enumerate}
            \item Исходный строковый вид команды передается на вход анализатору, который содержит в себе регулярные выражения для парсинга
            \item Происходит валидация кода(в первых версиях реализации валидации не было), в случае ошибки валидации - ошибки в количестве параметров функции, скобочках или невозможных символах - команда не будет выполнена и в лог действий будет выведена ошибка «компиляции» валидации
            \item Если команда успешно провалидирована начнется построение динамического дерева(\ref{sec:gloss:dyntree}), важно отметить, что в ходе выполнения команды дерево может менять свою структуру(\hyperref[sec:fif]{команда if}), а иногда даже создавать копии самого себя(\hyperref[sec:fcall]{CALL}). 
            \item Для построения динамического дерева(не бинарное дерево \ref{sec:gloss:bintree}) используется стандартный левосторонний обход, когда каждая следующая функция последовательно добавляется и спускается вглубь к следующему дочернему узлу, обойдя все элементы у первого дочернего узла, переходит ко второму, третьему и т.д.
            \item ПРИМЕЧАНИЕ. Особенными для разбора считаются функция IF, CALL и STRING в частности CALL и STRING останавливают дальнейший парсинг дочерних узлов функции и выставляют в результат строковое представление аргументов функции. Условная функция(оператор) IF - разбирает изначально только первый дочерний узел, оставшиеся два так же сохраняет в строковых представлениях
            \item После разбора команды в динамическое дерево можно запускать ее на исполнение 
            \item В изначальной реализации динамического языка - динамическое дерево полностью преобразовывалось в очередь и выполняло все команды последовательно по кругу пока все функции не будут выполнены, в более современной реализации очередь содержит только активные элементы выполняющиеся непосредственно в текущей итерации и последовательно добавляет родительские узлы непосредственно в тот момент, когда имеется возможность их выполнить, напомним, что родительский узел может быть выполнен только в случае когда все его дочерние команды вернули результат
            \item Выполнение начинается с самого глубокого уровня, если представить исходное динамическое дерево, то визуально его необходимо перевернуть и по слоям начать выполнять узлы дерева от листьев к корню, каждый следующий слой ожидает выполнения дочерних узлов предыдущего, в случае если функция является асинхронной, она не блокирует выполнение остальных команд на уровне
            \item ОСОБЕННОСТИ. Функции CALL и IF являются функциями модифицирующими динамическое дерево. Так функция CALL создает локальную копию поддерева их своих аргументов при этому есть два варианта(\hyperref[sec:fcall]{CALL})
            \item Функция IF на основе результата первого дочернего узла добавляет в исходное динамическое дерево либо второй, либо третий аргумент функции(третий может отсутствовать), происходит парсинг необходимой команды и динамическое дерево расширяется узлами дочерней функции внутри IF, параллельно выполняющейся в очереди начиная с уровня на котором размещен узел с IF(\hyperref[sec:fif]{подробнее про IF})
            \item В случае возникновения ошибок, возможны ситуации, которые прерывают дальнейшее выполнение команды.
            \item Результат корневого узла дерева обычно не используется и ничего не возвращает, за исключением  использование команды CALL.
        \end{enumerate}

        Понимая концепции порядка выполнения команд, а также особенности запуска циклов обработки команд можно писать сколько угодно сложные программные решения над динамическими формами.
    
    \section{Функция call}\label{sec:fcall}
        Если результат выполнения команды внутри CALL является динамической функцией создается дерево(\hyperref[sec:execrules]{Порядок выполнения}) если результат не является динамической функцией - исходная команда внутри CALL. Выполняется над другим элементом динамической формы указанным во втором параметре функции CALL

	\section{Операторы ветвления}\label{sec:fif}
	
	\section{Циклы}
	\label{sec:loops}
	
	Вооружившись ранее изученным набором команд, вам не составит труда реализовать цикл на динамическом языке.
	
	Напишем программу, которая выведет в поле <<Результат>> 100 точек:
	
	Добавьте  на динамическую форму скрытое поле с 'id' : 'counter'. Это поле будет служить счетчиком цикла.
	
	Ниже приведен полный листинг программы:
	
	\begin{verbatim}
	if(
	    [isnotin([getValue([counter])],[100])],
	       [run(
	           [setValue(
	               [plus(
	                   [getValue([result])],
	                   [.]
                   )],
	              [result]
	           )],
               [setValue(
	               [plus(
	                   [getValue([counter])],
	                   [1]
	               )],
	               [counter]
	           )],
	           [call(
	               [getValue([cmd])],
	               [this]
	           )]
	      )]
	)]
	\end{verbatim}
	
	Запустив программу, можно убедиться, что в поле <<Результат>> вывелось ровно 100 точек.
	
	Теперь рассмотрим принцип работы программы подробнее:
	
	\begin{verbatim}
	if(
	    [isnotin([getValue([counter])],[100])],
	\end{verbatim}
	
	В данном фрагменте кода мы проверяем, не выполняется ли условие неравенства нашего счетчика значению 100.
	
	В этом случае выполняем тело цикла, состоящее из 3-x команд внутри блока <<run>>:
	
	\begin{verbatim}
	setValue([plus([getValue([result])],[.])],[result])
	\end{verbatim}
	
	Здесь происходит добавление новой точки в поле с результатом.
	
	\begin{verbatim}
	setValue([plus([getValue([counter])],[1])],[counter])
	\end{verbatim}
	
	Увеличиваем значение счетчика на 1.
	
	\begin{verbatim}
	call([getValue([cmd])],[this])
	\end{verbatim}
	
	И, главная часть, обеспечивающая зацикливание нашей программы - вызываем повторное выполнение скрипта при помощи функции
	<<Call>>
	
	\section{Упражнения}
	
	Откройте шаблон <<Исполнятор>> и решите следующие задачи:
	
	\begin{enumerate}
	\item Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz»
	
	\end{enumerate}
	
	% Динамическая форма =====================================================================
	\chapter{Динамическая форма}
	
	\section{Что такое динамическая форма?}
	
	\section{Текстовые поля}
	
	\section{Списки}
	
	\section{Чекбоксы}
	
	% Группы ==================================================================================
	\chapter{Группы}
	
	\section{Виды групп}
	
	\section{Копирование групп}
	
	\section{Удаление групп}
	
	% Асинхронность ===========================================================================
	\chapter{Асинхронные команды}
	
	\section{Автоисполнятор}
	
	\section{Сопрограммы}

	% Паттерны ================================================================================
	\chapter{Паттерны программирования на динамическом языке}
	
	\section{Выделение функций}
	
Рассмотрим задачу формирования списка месяцев в зависимости от текущей даты: в элемент типа select требуется вывести название текущего и двух последующих месяцев. Вот как реализована эта функция в одном из шаблонов обращений:

\begin{verbatim}

if(
    [isin(
        [substr([getsysdate([+0])],[3],[5])],
        [01]
    )],
    [setSelectedValue(
        [null],
        [setValue(
            [Март],
            [setValue(
                [Февраль],
                [setValue(
                    [Январь],
                    [this]
                )]
            )]
        )]
    )],
    [if(
        [isin(
            [substr([getsysdate([+0])],[3],[5])],
            [02]
        )],
        [setSelectedValue(
            [null],
            [setValue(
                [Апрель],
                [setValue(
                    [Март],
                    [setValue(
                        [Февраль],
                        [this]
                    )]
                )]
            )]
        )],
        [if(
            [isin(
                [substr([getsysdate([+0])],[3],[5])],
                [03]
            )],
            [setSelectedValue(
                [null],
                [setValue(
                    [Май],
                    [setValue(
                        [Апрель],
                        [setValue(
                            [Март],
                            [this]
                        )]
                    )]
                )]
            )],
            [if(
                [isin(
                    [substr([getsysdate([+0])],[3],[5])],
                    [04]
                )],
                [setSelectedValue(
                    [null],
                    [setValue(
                        [Июнь],
                        [setValue(
                            [Май],
                            [setValue(
                                [Апрель],
                                [this]
                            )]
                        )]
                    )]
                )],
                [if(
                    [isin(
                        [substr([getsysdate([+0])],[3],[5])],
                        [05]
                    )],
                    [setSelectedValue(
                        [null],
                        [setValue(
                            [Июль],
                            [setValue(
                                [Июнь],
                                [setValue(
                                    [Май],
                                    [this]
                                )]
                            )]
                        )]
                    )],
                    [if(
                        [isin(
                            [substr([getsysdate([+0])],[3],[5])],
                            [06]
                        )],
                        [setSelectedValue(
                            [null],
                            [setValue(
                                [Август],
                                [setValue(
                                    [Июль],
                                    [setValue(
                                        [Июнь],
                                        [this]
                                    )]
                                )]
                            )]
                        )],
                        [if(
                            [isin(
                                [substr([getsysdate([+0])],[3],[5])],
                                [07]
                            )],
                            [setSelectedValue(
                                [null],
                                [setValue(
                                    [Сентябрь],
                                    [setValue(
                                        [Август],
                                        [setValue(
                                            [Июль],
                                            [this]
                                        )]
                                    )]
                                )]
                            )],
                            [if(
                                [isin(
                                    [substr([getsysdate([+0])],[3],[5])],
                                    [08]
                                )],
                                [setSelectedValue(
                                    [null],
                                    [setValue(
                                        [Октябрь],
                                        [setValue(
                                            [Сентябрь],
                                            [setValue(
                                                [Август],
                                                [this]
                                            )]
                                        )]
                                    )]
                                )],
                                [if(
                                    [isin(
                                        [substr([getsysdate([+0])],[3],[5])],
                                        [09]
                                    )],
                                    [setSelectedValue(
                                        [null],
                                        [setValue(
                                            [Ноябрь],
                                            [setValue(
                                                [Октябрь],
                                                [setValue(
                                                    [Сентябрь],
                                                    [this]
                                                )]
                                            )]
                                        )]
                                    )],
                                    [if(
                                        [isin(
                                            [substr([getsysdate([+0])],[3],[5])],
                                            [10]
                                        )],
                                        [setSelectedValue(
                                            [null],
                                            [setValue(
                                                [Декабрь],
                                                [setValue(
                                                    [Ноябрь],
                                                    [setValue(
                                                        [Октябрь],
                                                        [this]
                                                    )]
                                                )]
                                            )]
                                        )],
                                        [if(
                                            [isin(
                                                [substr([getsysdate([+0])],[3],[5])],
                                                [11]
                                            )],
                                            [setSelectedValue(
                                                [null],
                                                [setValue(
                                                    [Январь],
                                                    [setValue(
                                                        [Декабрь],
                                                        [setValue(
                                                            [Ноябрь],
                                                            [this]
                                                        )]
                                                    )]
                                                )]
                                            )],
                                            [if(
                                                [isin(
                                                    [substr([getsysdate([+0])],[3],[5])],
                                                    [12]
                                                )],
                                                [setSelectedValue(
                                                    [null],
                                                    [setValue(
                                                        [Февраль],
                                                        [setValue(
                                                            [Январь],
                                                            [setValue(
                                                                [Декабрь],
                                                                [this]
                                                            )]
                                                        )]
                                                    )]
                                                )],
                                                []
                                            )]
                                        )]
                                    )]
                                )]
                            )]
                        )]
                    )]
                )]
            )]
        )]
    )]
)
\end{verbatim}

Как видим, данный пример содержит много повторяющихся элементов участков кода - по одному фрагменту на каждый из 12 месяцев. Хорошо, что в нашем календаре их не 42! Представьте объем доработок при изменении требований к задаче: например, заказчику потребуется выводить по 6 названий месяцев!

Приступим же к рефакторингу!

Первым делом, обратим внимание на повторяющийся фрагмент кода:

\begin{verbatim}
[substr([getsysdate([+0])],[3],[5])]
\end{verbatim}

Это скрипт получения значения номера текущего месяца.
Вычислим его один раз и запомним в отдельном скрытом поле формы:

\begin{verbatim}
<text id="month_num" visible="false"
        sbcommand="setValue([substr([getsysdate([+0])],[3],[5])],[this])]" 
 />
\end{verbatim}

Далее, нам потребуется структура для выставляения соответствия номерам месяцев их названий. С этой задачей отлично справляется элемент <<select>> :

\begin{verbatim}
<select id="months" visible="false"> 

<option label="Январь">1</option>
<option label="Февраль">2</option>
<option label="Март">3</option>
<option label="Апрель">4</option>
<option label="Май">5</option>
<option label="Июнь">6</option>
<option label="Июль">7</option>
<option label="Август">8</option>
<option label="Сентябрь">9</option>
<option label="Октябрь">10</option>
<option label="Ноябрь">11</option>
<option label="Декабрь">12</option>
<option label="Январь">13</option>
<option label="Февраль">14</option>

</select>
\end{verbatim}

Обратите внимание, что мы указали 2 <<лишних>> месяца -- это потребуется для корректной работы нашего алгоритма в ноябре и декабре.

Добавим на динамическую форму select для вывода результата:
\begin{verbatim}
<select id="result" visible="true"> 
\end{verbatim}

Реализуем функцию добавления в наш новый контрол очередного месяца:

\begin{verbatim}
<text id="add_month">
setValue(
    [getValue(
        [setSelectedValue(
            [plus(
                [getValue([month_num])],
                [getValue([i])]
            )], 
            [months]
        )],
        [result]
    )],
    [result]
)
</text>
\end{verbatim}

Где <<i>> - простое скрытое поле для хранения счетчика:
\begin{verbatim}
<text id="month_num" visible="false">0</text>
\end{verbatim}

Для добавления нового месяца в итоговый select достаточно выполнить вызвать нашу функцию <<add\_month>> через оператор call: 

\begin{verbatim}
call([getValue([add_month])],[this])
\end{verbatim}

Теперь, для решения нашей задачи потребуется выполнить скрипт <<add\_month>> трижды, меняя значение <<i>>:

\begin{verbatim}
run(
    [call([getValue([add_month])],[this])],
    [setValue([1],[i])],
    [call([getValue([add_month])],[this])],
    [setValue([2],[i])],
    [call([getValue([add_month])],[this])],
    [setSelectedValue([null],[result])]
)
\end{verbatim}

\section{Упражнения}

        \begin{enumerate}
            \item Используя код разобранного выше примера, решите задачу: в элемент типа select требуется вывести название текущего и 5 последующих нечетных месяцев. Для решения задачи рекомендуется использовать подход к реализации циклов, рассмотренный в  \autoref{sec:loops}            
        \end{enumerate}
\chapter{Глоссарий}
    \section{Бинарное дерево}\label{sec:gloss:bintree}
        Иерархическая структура данных, в которой каждый узел имеет не более двух потомков (детей). Как правило, первый называется родительским узлом, а дети называются левым и правым наследниками. Двоичное дерево не является упорядоченным ориентированным деревом
    \section{Динамическое дерево}\label{sec:gloss:dyntree}
        Иерархическая структура данных, в которой каждый узел имеет от 0 и более потомков (детей). ОСобенностью структуру является то что она не статическаая и может произвольно изменяться(модифицироваться) внутренними узлами самой структуры
    \section{Команда}\label{sec:gloss:command}
        Одна или более функций динамического языка объединенных в последовательный блок выполнения(в рамках процедурного подхода команду можно интерпретировать как процедуру)
\end{document}
