\documentclass[../index.tex]{subfiles}
\begin{document}
Если заглянуть в истоки зарождения динамических форм, изначально не было реализовано поддержки элементов типа группа и поэтому было принято решение о том чтобы постараться с эмулировать понятие группы так чтобы элементы группировались по параметру \textbf{groupid}, так появились плоские группы и legacy группы(в рамках реализации domcore названные - нормализованные группы), позже механизм групп был добавлен в интерфейсы ЕСО, но для полноценного функционирования механизма групп в старых шаблонах необходимо уметь работать со всеми видами групп. Остановимся на типах групп подробнее в следующем разделе.
\section{Виды групп}
    На момент написания книги можно выделить три основные типа групп:
\begin{enumerate}
    \item Плоские группы. Плоские группы представляют собой элементы группируемые по параметру \textbf{groupid}, но при этом такие группы не имею заголовка как такового, при отображении не визуализируются как группа, основной задачей, которой решают данные группы - сортировка и как ни странно группировка элементов в одном блоке. Важно заметить при сохранении группы такого формата должны быть преобразованы обратно в список без группы.
    \item Legacy группы. Основное отличие от плоских групп в наличие заголовка. Есть отличительная особенность поддержки  Legacy групп Лице Друга 1.0 и domcore библиотеке: В первом случае поддерживается наличие более одного заголовка в группе, во втором же принято решение что заголовок группы может быть один. Все остальные заголовки не обрезаются при обработке динамической формы. При визуализации Legacy Group могут сворачиваться и управляться командой динамического языка \textbf{setFocus}. При сохранении они могут не разворачиваться и отправляться как нормальные группы, за исключением шаблонов помеченных атрибутом needunwrap, требующего развернуть
    \item Группы. Стандартный механизм групп приходящий с заголовком внутренними элементами. Работа происходит в точности как с Legacy группами, за исключением, что их никогда не нужно разворачивать
\end{enumerate}
    Каждая группа имеет несколько механизмов - копирование, удаление и сворачивание. Если сворачивание группы это в большей степени чисто визуальный функционал, за исключением момента с использование функции \textbf{setFocus} над  заголовком группы. То копирование и удаление групп это отдельный функционал о котором мы поговорим в следующих разделах.
\section{Копирование групп}

Копирование групп - стандартный функционал поддерживаемый динамическим языком и позволяющий гибко настраивать механизм копирования. Копирование группы вызывается командой динамического языка \textbf{copyGroup}(Подробнее о ней можно прочитать в разделе Команды динамического языка). Стандартно принято прописывать копирование группы либо в sbcommand(раздел Динамические формы), либо при нажатии на кнопку addButton вложенную в группу.
Функционал копирования групп привязан к исходному состоянию объекта в динамической форме, а не к его состоянию в момент копирования. Чтобы понять давайте посмотрим на примере:
У нас из формы пришла группа:
\begin{verbatim}
{
    "objectType": "group",
    "logicalType": "group",
    "id": "groupaddress",
    "label": "Пункт отправления/прибытия",
    "mandatory": false,
    "style": "group",
    "visible": true,
    "width": "",
    "sbobject": null,
    "sbdbfield": "groupAddressTo",
    "sbonload": "[run(\n\t[if([iam([approver])],\n\t\t[if([isin([getApprovalStage([this])],[Подтверждение поездки])],\n\t\t\t[setCloseVisible([true],[this])],\n\t\t\t[if([isin([getApprovalStage([this])],[Утверждение поездки])],\n\t\t\t\t[setCloseVisible([true],[this])],\n\t\t\t\t[setCloseVisible([false],[this])]\n\t\t\t)]\n\t\t)],\n\t\t[setCloseVisible([false],[this])]\n\t)]\n)]\t",
    "sbcopyinfo": false,
    "childs": [
        {
        "objectType": "select",
        "logicalType": "combo",
        "id": "addressto",
        "label": "Маршрут следования",
        "mandatory": true,
        "sbcommand": "",
        "sbmask": "",
        "sbmodify": true,
        "sbtask": "if(\r\n\t[run([setValue([getDistance([ getValues([ find([id],[address], [grouptrip]) ]) ])],[array])])],\r\n\t[if(\r\n\t\t[isin([getText([distance],[array])],[])],\r\n\t\t[run(\r\n\t\t\t[clear([array])],\r\n\t\t\t[setValue([0,00],[cost])],\r\n\t\t\t[setValue([plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])],[allcost])],\r\n\r\n\t\t\t[setValue([0,000],[distancetext])],\r\n\t\t\t[setValue([0],[timetext])],\r\n\r\n\t\t\t[setValue([0],[distancevalue])],\r\n\t\t\t[setValue([0],[kmdistancevalue])],\r\n\r\n\t\t\t[setValue([0],[timevalue])],\r\n\r\n\t\t\t[setValue([plus([#0.000],[div([#0.000], [plus([#0.000],[getTexts([find([id],[plus([distanc],[evalue])],[])])])], [1000])])],[alldistancetext])],\r\n\t\t\t[setValue( [plus([div([#0], [plus([#0.00],[getTexts([find([id],[plus([tim],[evalue])],[])])])], [60])])] ,[alltimetext])]\r\n\t\t)],\r\n\t\t[run(\r\n\t\t\t[setValue([getText([time_text],[array])],[timetext])],\r\n\t\t\t[setValue([div([#0.000],[getText([distance],[array])],[1000])],[distancetext])],\r\n\t\t\t[setValue([getText([time],[array])],[timevalue])],\r\n\r\n\t\t\t[setValue([getText([distance],[array])],[distancevalue])],\r\n\t\t\t[setValue([div([#0.000],[getText([distance],[array])],[1000])],[kmdistancevalue])],\r\n\r\n\t\t\t[if(\r\n\t\t\t\t[run(\r\n\t\t\t\t\t[setValid([true],[],[pricelabel])],\r\n\t\t\t\t\t[setValues([_getCost([FF_GET_CONDITIONAL_PRICE_DOUBLE],[getUser([TabNum])],[getText([distance],[array])],[getText([time],[array])],[getText([cfgtransporttype])],[plus([#0.00],[getTexts([find([id],[wait], [grouptrip])])])],[cost],[1],[getValue([date])],[getUser([template])])],[cost])]\r\n\t\t\t\t\t)],\r\n\t\t\t\t[run(\r\n\t\t\t\t\t[setValue( [plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])], [allcost])],\r\n\t\t\t\t\t[setValue([plus([#0.000],[div([#0.000], [plus([#0.000],[getTexts([find([id],[plus([distanc],[evalue])],[])])])], [1000])])],[alldistancetext])],\r\n\t\t\t\t\t[setValue( [plus([div([#0], [plus([#0.00],[getTexts([find([id],[plus([tim],[evalue])],[])])])], [60])])] ,[alltimetext])]\r\n\t\t\t\t)],\r\n\t\t\t[])])])\r\n\t],\r\n\t[]\r\n)",
        "sbtitle": "",
        "sbtype": "address",
        "sbstyle": "width:65%",
        "style": "combo",
        "visible": true,
        "width": "",
        "sbobject": null,
        "sbdbfield": "addressTo",
        "groupid": ""
        },
        {
        "objectType": "text",
        "logicalType": "date",
        "id": "wait",
        "label": "Время ожидания",
        "mandatory": false,
        "sbcommand": "run([setMinHours([0],[setMaxHours([2],[this])])], [if([isin([getValue([cfgtransporttype])],[Такси])],[setVisible([true],[this])],[run([setVisible([false],[this])],[setStyle([width],[100%],[addressto])])])])",
        "sbmask": "HH:mm",
        "sbmodify": true,
        "sbtask": "if(\n    [run([setValue([getDistance([getValues([find([id],[address],[grouptrip])])])],[array])])],\n    \n    [if(\n        [isin([getText([distance],[array])],[])],\n        [run(\n            [clear([array])],\n            [setValue([0,00],[cost])],\n            [setValue([plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])],[allcost])],\n            [setValue([Не рассчитатно],[distancetext])],\n            [setValue([Не рассчитано],[timetext])]\n        )],\n        [run(\n            [setValue([getText([time_text],[array])],[timetext])],\n            [setValue([div([#0.000],[getText([distance],[array])],[1000])],[distancetext])],\n            [if(\n                [run([setValid([true],[],[pricelabel])],[setValues([_getCost([FF_GET_CONDITIONAL_PRICE_DOUBLE],[getUser([id])],[getText([distance],[array])],[getText([time],[array])],[getText([cfgtransporttype])],[plus([#0.00],[getTexts([find([id],[wait], [grouptrip])])])],[cost],[1],[getValue([date])],[getUser([template])])],[cost])])],\n                [setValue([plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])],[allcost])],\n                []\n            )]\n        )]\n    )],\n    []\n)",
        "sbtitle": "",
        "sbtype": "",
        "sbstyle": "width:35%",
        "style": "text",
        "visible": false,
        "width": "",
        "sbcopyinfo": false,
        "childs": null,
        "groupid": "distanation"
        },
        {
        "objectType": "checkbox",
        "logicalType": "buttonAdd",
        "id": "addgroupaddress",
        "label": "Добавить еще один адрес",
        "mandatory": false,
        "sbcommand": "",
        "sbmodify": true,
        "sbtask": "copyGroup([groupaddress],[this])",
        "sbtitle": "",
        "sbtype": "buttonadd",
        "sbstyle": "",
        "style": "checkbox",
        "visible": true,
        "width": "",
        "sbdbfield": "addGroupAddress",
        "text": "if([run([setValue([getDistance([getValues([find([id],[address],[grouptrip])])])],[array])])],[if([isin([getText([distance],[array])],[])],[run([clear([array])],[setValue([0,00],[cost])],[setValue([0,000],[distancetext])],[setValue([0],[timetext])],[setValue([0],[distancevalue])],[setValue([0],[kmdistancevalue])],[setValue([0],[timevalue])],[if([isin([isVisible([approvebox])],[false])],[run([setValue([plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])],[allcost])],[setValue([plus([#0.000],[div([#0.000], [plus([#0.000],[getTexts([find([id],[plus([distanc],[evalue])],[])])])], [1000])])] ,[alldistancetext])],[setValue([plus([div([#0], [plus([#0.00],[getTexts([find([id],[plus([tim],[evalue])],[])])])], [60])])],[alltimetext])])],[if([isin([getValue([approvebox])],[true])],[run([setValue([plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])],[allcost])],[setValue([plus([#0.000],[div([#0.000], [plus([#0.000],[getTexts([find([id],[plus([distanc],[evalue])],[])])])], [1000])])] ,[alldistancetext])],[setValue([plus([div([#0], [plus([#0.00],[getTexts([find([id],[plus([tim],[evalue])],[])])])], [60])])],[alltimetext])])],[])],)])],[run([if([run([setValid([true],[],[pricelabel])],[setValues([_getCost([FF_GET_CONDITIONAL_PRICE_DOUBLE],[getUser([TabNum])],[getText([distance],[array])],[getText([time],[array])],[getText([cfgtransporttype])],[plus([#0.00],[getTexts([find([id],[wait], [grouptrip])])])],[cost],[1],[getValue([date])],[getUser([template])])],[cost])])],[if([isin([getSize([getValues([find([id],[address],[grouptrip])])])],[1])],[run([clear([array])],[setValue([0,00],[cost])],[setValue([0,000],[distancetext])],[setValue([0],[timetext])],[setValue([0],[distancevalue])],[setValue([0],[kmdistancevalue])],[setValue([0],[timevalue])],[if([isin([isVisible([approvebox])],[false])],[run([setValue([plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])],[allcost])],[setValue([plus([#0.000],[div([#0.000], [plus([#0.000],[getTexts([find([id],[plus([distanc],[evalue])],[])])])], [1000])])],[alldistancetext])],[setValue([plus([div([#0], [plus([#0.00],[getTexts([find([id],[plus([tim],[evalue])],[])])])], [60])])] ,[alltimetext])])],[if([isin([getValue([approvebox])],[true])],[run([setValue([plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])],[allcost])],[setValue([plus([#0.000],[div([#0.000], [plus([#0.000],[getTexts([find([id],[plus([distanc],[evalue])],[])])])], [1000])])],[alldistancetext])],[setValue([plus([div([#0], [plus([#0.00],[getTexts([find([id],[plus([tim],[evalue])],[])])])], [60])])] ,[alltimetext])])],[])],)])],[run([setValue([getText([time_text],[array])],[timetext])],[setValue([div([#0.000],[getText([distance],[array])],[1000])],[distancetext])],[setValue([getText([time],[array])],[timevalue])],[setValue([getText([distance],[array])],[distancevalue])],[setValue([div([#0.000],[getText([distance],[array])],[1000])],[kmdistancevalue])],[if([isin([isVisible([approvebox])],[false])],[run([setValue([plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])],[allcost])],[setValue([plus([#0.000],[div([#0.000],[plus([#0.000],[getTexts([find([id],[plus([distanc],[evalue])],[])])])],[1000])])],[alldistancetext])],[setValue([plus([div([#0],[plus([#0.00],[getTexts([find([id],[plus([tim],[evalue])],[])])])], [60])])],[alltimetext])])],[if([isin([getValue([approvebox])],[true])],[run([setValue([plus([#0.00],[getTexts([find([id],[plus([c],[ost])],[])])])],[allcost])],[setValue([plus([#0.000],[div([#0.000],[plus([#0.000],[getTexts([find([id],[plus([distanc],[evalue])],[])])])],[1000])])],[alldistancetext])],[setValue([plus([div([#0],[plus([#0.00],[getTexts([find([id],[plus([tim],[evalue])],[])])])], [60])])],[alltimetext])])],[])],)])])],[])])])],[])",
        "groupid": "distanation"
        }
    ]
}
\end{verbatim}
Мы изменяем заполняем значение Маршрут следования и время ожидания, и при нажатии на кнопку "Добавить еще один адрес» выполняется команда sbtask в которой вызывается копировани группы и происходит магия - копируется группа, но все заполненные нами поля не учитываются и поля Маршрут следования и время ожидания в новой созданной группе будут пустыми. Точно так же происходит и с новыми элементами, если в группе динамическим языком добавятся новые элементы, то при копировании они не будут учтены и новая группа создастся без них. 
Итого -  при копировании группы не учитываются никакие изменения произведенные с элементами группы и самой группой. В том числе не учитываются изменения видимости, обязательности, возможности изменений и т.д. 

Еще одной важной особенностью является визуальное отображения кнопок копирования. Функционально не запрещено, но визуально скрываются все кнопки для копирования групп кроме последней в наборе. То есть нажать на кнопку и добавить можно только в конец группы, но это только визуальное ограничение сделанное для более эстетичного вида. 
Исключительной особенностью обладают группы элементы которых помещаются в одну строчку. Визуальное отображение элементов разделено от функционального. Если элементы группы для всех скопированных групп из одного множества удовлетворяют условию что все элементы по ширине могу уместиться в одной строке(кнопка для копирования группы не учитывается при вычислениях), то визуально все группы склеиваются в одну и отображаются как общая группа с одним заголовком, при этом функциональная часть остается неизменной, там все также это представляется как разные группы.
Если копирование работает над Плоской группой - проверять условия описанные выше не имеет смысла, так как плоские группы не имеют заголовка, поэтому проверка производится только для групп типа Lygacy и стандартных групп
\section{Удаление групп}

Удаление групп - операция позволяющая удалить любую в том числе и первую группу в подмножетсве скопированных групп. Эта функция одна из немногих, которые не реализованы в динамическом языке, а разрешаются с использованием вызовов обработчиков через UI.
Удаление групп возможно только в том случае если групп в подмножестве больше 1-ой(2, 3 и т.д.). При добавлении группы через копирование у всех групп появляется возможность закрыть(удалить группу) визуально отображается в виде крестика над группой или элементом если группы склеились в одну.
При нажатии на крестик происходит поиск группы и удаление ее, а дополнительно перед удалением у той группы, которую удаляют находят элемент \textbf{buttonAdd} и вызывают команду выполнение команды динамического языка установленную в параметр \textbf{text} этого поля. Что позволяет например вести пересчеты расстояний и стоимости поездки при удалении адреса из маршрута.

\end{document}