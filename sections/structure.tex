\documentclass[../index.tex]{subfiles}

\newglossaryentry{bintree}
{
    name=Бинарное дерево,
    description={Иерархическая структура данных, в которой каждый узел имеет не более двух потомков (детей). Как правило, первый называется родительским узлом, а дети называются левым и правым наследниками. Двоичное дерево не является упорядоченным ориентированным деревом}
}

\newglossaryentry{dyntree}
{
    name=Динамическое дерево,
    description={Иерархическая структура данных, в которой каждый узел имеет от 0 и более потомков (детей). ОСобенностью структуру является то что она не статическаая и может произвольно изменяться(модифицироваться) внутренними узлами самой структуры}
}

\begin{document}

\section{Синтаксис}

Инструкции динамического языка представляют собой комбинации из конструкций всего двух типов: вызовов функций и литералов.

Основной конструкцией языка является \textit{функция}. Она состоит из имени и параметров. 
Сразу после имени функции следует символ '\verb|(|', за которым могут следовать один или 
несколько параметров, после этого вся конструкция завершается '\verb|)|', 
Некоторые функции вовсе не принимают параметры, см. листинг \ref{lst:lecsic}(1). 
Также поддерживается несколько параметров которые можно разделять символом '\verb|,|'
пример \ref{lst:lecsic}(2,3), но не все среды выполнения (см. главу \ref{sec:environment}) 
поддерживают символ переноса строки, используя вместо него последовательность \verb|\r\n|.
Параметры функции можно переносить на следующую строку и добавлять пробелы для 
лучшей читаемости программы, \ref{lst:lecsic}(3)

Скобки после имени функции являются обязательными даже если у функции нет праметров.
Каждый параметр функции необходимо обернуть в '\verb|[|' '\verb|]|'.
Параметром функции может быть литеральное значение или вызов другой функции, вне зависимости от этого 
параметр необходимо обернуть в '\verb|[|' '\verb|]|'.

Функции строго предопределены в стандартной библиотеке функций (см. главу \ref{sec:stdlib}).

Литералы представляют собой константы, включаемые непосредственно в текст программы. 
Литералы не могут быть изменены в тексте программы.

\begin{figure}\label{lst:lecsic}
\begin{verbatim}
(1) func()

(2) func([arg0], [arg1], [argN])

(3) func(
        [arg0], [arg1]
        ,[arg2]
    )
\end{verbatim}        
\end{figure}

\section{Типы данных}\label{sec:types}

Динамический язык это зыком с динамической типизацией\footnotemark, определение типа происходит 
непосредственно перед передачей аргумента в функцию. 

\begin{footnotetext}
динамическая типизация -- приём, широко используемый в языках программирования и языках спецификации, 
при котором переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной.
\end{footnotetext}

Правила, по которым происходит преведение типа, следующие:

значение считается \textbf{числом}, если его строковое представление содержит только цифры и знак разделителя \verb|,| или \verb|.|.

значение считается  \textbf{логическим}, если строковое представление представляет собой последовательности \verb|true| или
 \verb|false|, вне зависимости от регистра символов.

В остальных случаях значением считается строкой символов.

*** Добавить примеры ***

\section{Переменные}
Динамический язык не поддерживает определение и присвоение пременыых. Однако функции позволяют изменять элементы 
динамической формы и значения в этих элементах можно считать совего рода переменными.

\section{Функции}


***Возвращаемые значения

Все функции стандартной библиотеки динамического языка возвращают значение. Например,

\verb|getValue([foo])| -- вернет значение элемента, определяемого по идентификатору <<foo>> формы.

Функции, созданные для выполнения побочных эффектов, возвращают значение, как правило -- <<id>> элемента формы, над которым производится операция:

\verb|setValue([foo], [bar])| -- вернет <<bar>>

Даже функции, для которых в стандартной библиотеке возвращаемое значение не определено -- вернут пустой литерал: \verb|[]|

\section{Структуры данных}
Функции помимо литеральных значений могут принимать и возвращать определенные структуры данных Map и 3DMap.
Это необходимо для реализации вызова некоторых функций автоисполнятора (см. главу \ref{sec:autorun})

\textbf{Map} это структура данных \textbf{ключ} - \textbf{значение}. 
Обычно используется для хранения выбраного пункта в элементах типа \textbf{select} и \text{suggest} (см. главу \ref{sec:dynform}) 
как правило ключ являеться идентификаторм пункта, значение отображаемым тексто для пользователя. Но для элементов
\textbf{suggest} применяются немного другие правила (см. главу \ref{sec:dynlang:traps})

\textbf{3DMap} структура данных для обмена дин формой между автоисполняторм и клиентской системой. 
Напрямую дануую структуру использовать нельзя, она передается и принимается автоматически при вызове функций
название которых начинается с \verb{__} (да нижних подчеркивания). При вызове таких функций клиентский код помимо передачи 
параметров функции также предает информацию обо всех атрибутах дин формы, а при ответе ожидает структуру которая описывает
изменение атрибутов и значений существующих элементов, а также информацию об элементах которые необходимо добавить.
Примеры данных структур можно посмотреть в приложении \ref{apx:3dmap}

\section{Порядок выполнения}\label{sec:execrules} 
В основу выполнения команд динамического языка лежит простая концепция -- выполнение функций должно происходить по слоям из самого глубокого вложенной функции к корневому элементу, при этом функция не может быть выполнена, пока не выполнены все ее дочерние элементы.

Итак поэтапно разберем последовательность действий происходящих при парсинге команд:
\begin{enumerate}
    \item Исходный строковый вид команды передается на вход анализатору, который содержит в себе регулярные выражения для парсинга
    \item Происходит валидация кода(в первых версиях реализации валидации не было), в случае ошибки валидации -- ошибки в количестве параметров функции, скобочках или невозможных символах - команда не будет выполнена и в лог действий будет выведена ошибка валидации
    \item Если команда успешно провалидирована, начнется построение динамического дерева(\gls{dyntree}). Важно отметить, что в ходе выполнения команды, дерево может менять свою структуру(\hyperref[sec:fif]{команда if}), а иногда даже создавать копии самого себя(\hyperref[sec:fcall]{CALL}). 
    \item Для построения динамического дерева(не бинарное дерево \gls{bintree}) используется стандартный левосторонний обход, когда каждая следующая функция последовательно добавляется и спускается вглубь к следующему дочернему узлу, обойдя все элементы у первого дочернего узла, переходит ко второму, третьему и т.д.
    \item ПРИМЕЧАНИЕ. Особенными для разбора считаются функция IF, CALL и STRING в частности CALL и STRING останавливают дальнейший парсинг дочерних узлов функции и выставляют в результат строковое представление аргументов функции. Условная функция(оператор) IF -- разбирает изначально только первый дочерний узел, оставшиеся два так же сохраняет в строковых представлениях
    \item После разбора команды в динамическое дерево можно запускать ее на исполнение 
    \item В изначальной реализации динамического языка - динамическое дерево полностью преобразовывалось в очередь и выполняло все команды последовательно по кругу пока все функции не будут выполнены, в более современной реализации очередь содержит только активные элементы выполняющиеся непосредственно в текущей итерации и последовательно добавляет родительские узлы непосредственно в тот момент, когда имеется возможность их выполнить, напомним, что родительский узел может быть выполнен только в случае когда все его дочерние команды вернули результат
    \item Выполнение начинается с самого глубокого уровня, если представить исходное динамическое дерево, то визуально его необходимо перевернуть и по слоям начать выполнять узлы дерева от листьев к корню, каждый следующий слой ожидает выполнения дочерних узлов предыдущего, в случае если функция является асинхронной, она не блокирует выполнение остальных команд на уровне
    \item ОСОБЕННОСТИ. Функции CALL и IF являются функциями модифицирующими динамическое дерево. Так функция CALL создает локальную копию поддерева их своих аргументов при этому есть два варианта(\hyperref[sec:fcall]{CALL})
    \item Функция IF на основе результата первого дочернего узла добавляет в исходное динамическое дерево либо второй, либо третий аргумент функции(третий может отсутствовать), происходит парсинг необходимой команды и динамическое дерево расширяется узлами дочерней функции внутри IF, параллельно выполняющейся в очереди начиная с уровня на котором размещен узел с IF(\hyperref[sec:fif]{подробнее про IF})
    \item В случае возникновения ошибок, возможны ситуации, которые прерывают дальнейшее выполнение команды.
    \item Результат корневого узла дерева обычно не используется и ничего не возвращает, за исключением  использование команды CALL.
\end{enumerate}

Понимая концепции порядка выполнения команд, а также особенности запуска циклов обработки команд можно автоматизировать сколько угодно сложные наборы операций над динамическими формами.

\section{Функция call}\label{sec:fcall}
    Если результат выполнения команды внутри CALL является динамической функцией создается дерево(\hyperref[sec:execrules]{Порядок выполнения}) если результат не является динамической функцией - исходная команда внутри CALL. Выполняется над другим элементом динамической формы указанным во втором параметре функции CALL

\section{Операторы ветвления}\label{sec:fif}

\section{Циклы}\label{sec:loops}

    Вооружившись ранее изученным набором команд, вам не составит труда реализовать цикл на динамическом языке.
    
    Напишем программу, которая выведет в поле <<Результат>> 100 точек:
    
    Добавьте  на динамическую форму скрытое поле с 'id' : 'counter'. Это поле будет служить счетчиком цикла.
    
    Ниже приведен полный листинг программы:
    
    \begin{verbatim}
    if(
        [isnotin([getValue([counter])],[100])],
        [run(
            [setValue(
                [plus(
                    [getValue([result])],
                    [.]
                )],
                [result]
            )],
            [setValue(
                [plus(
                    [getValue([counter])],
                    [1]
                )],
                [counter]
            )],
            [call(
                [getValue([cmd])],
                [this]
            )]
        )]
    )]
    \end{verbatim}
    
    Запустив программу, можно убедиться, что в поле <<Результат>> вывелось ровно 100 точек.
    
    Теперь рассмотрим принцип работы программы подробнее:
    
    \begin{verbatim}
    if(
        [isnotin([getValue([counter])],[100])],
    \end{verbatim}
    
    В данном фрагменте кода мы проверяем, не выполняется ли условие неравенства нашего счетчика значению 100.
    
    В этом случае выполняем тело цикла, состоящее из 3-x команд внутри блока <<run>>:
    
    \begin{verbatim}
    setValue([plus([getValue([result])],[.])],[result])
    \end{verbatim}
    
    Здесь происходит добавление новой точки в поле с результатом.
    
    \begin{verbatim}
    setValue([plus([getValue([counter])],[1])],[counter])
    \end{verbatim}
    
    Увеличиваем значение счетчика на 1.
    
    \begin{verbatim}
    call([getValue([cmd])],[this])
    \end{verbatim}
    
    И, главная часть, обеспечивающая зацикливание нашей программы - вызываем повторное выполнение скрипта при помощи функции
    <<Call>>
    
\section{Упражнения}
    
    Откройте шаблон <<Исполнятор>> и решите следующие задачи:
    
    \begin{enumerate}
    \item Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz»
    
    \end{enumerate}
\end{document}