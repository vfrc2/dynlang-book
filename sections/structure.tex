\documentclass[../index.tex]{subfiles}

\newglossaryentry{bintree}
{
    name=Бинарное дерево,
    description={Иерархическая структура данных, в которой каждый узел имеет не более двух потомков (детей). Как правило, первый называется родительским узлом, а дети называются левым и правым наследниками. Двоичное дерево не является упорядоченным ориентированным деревом}
}

\newglossaryentry{dyntree}
{
    name=Динамическое дерево,
    description={Иерархическая структура данных, в которой каждый узел имеет от 0 и более потомков (детей). ОСобенностью структуру является то что она не статическаая и может произвольно изменяться(модифицироваться) внутренними узлами самой структуры}
}

\begin{document}

\section{Лексические конструкции языка}
Основой языка явлются функции и литеральные значения. Как таковых переменых язык не поддерживыает, 
но это недостаток может быть исправлен применением динамической формы (см. главу \ref{sec:dynfom}). 
Лексические конструкции преведены в листинге \ref{lst:lecsic}. 

Основной конструкцией языка является \textit{функция}. Она состоит из имени и параметров. 
Сразу после имени функции следует символ '\verb|(|', за которым следует один или 
несколько параметров, после этого вся конструкция завершается '\verb|)|', 
Параметры функции не обязательны, то есть у функции может не быть параметров 
например как листинге \ref{lst:lecsic}(1). 
Также поддерживается несколько параметров которые можно разделять символом '\verb|,|'
пример \ref{lst:lecsic}(2,3), но не все среды выполнения (см. главу \ref{sec:environment}) 
поддерживают символ переноса строки, используя вместо него последовательность \verb|\r\n|.
Параметры функции можно переносить на следующую строку и добавлять пробелы для 
лучшей читаемости программы, \ref{lst:lecsic}(3)

Скобки после имени функции являются обязательными даже если у функции нет праметров.
Каждый параметр функции необходимо обернуть в '\verb|[|' '\verb|]|'.
Параметром функции может быть литеральное значение или вызов другой функции, внезависмости от этого 
параметр необходмо обернуть в '\verb|[|' '\verb|]|'.

Функции строго предопределены в стандартной библиотеке функций (см. главу \ref{sec:stdlib}) которая определяет набор возможных имен функций.

Есть специальные функции \verb|if| и \verb|string| у которых не совсем стандартное поведение,
и есть особености выполнения.

\textit{Литеральные значения} могут быть трех разных типов: \textit{строка}, \textit{число},
\textit{логическое значение}. На деле все литералы -- это строки, язык имеет динамическое 
приведение типов и в зависимости от ожидаемых параметров функции определяет тип.

Правила по которым происодит приведение типов такие:

числа: если строка содержит только цифры и знак разделителя \verb|,| \verb|.| 

логическое значение: если строка содержит слова \verb|true| или \verb|false|, вне зависимости от регистра символов.


\begin{figure}\label{lst:lecsic}
\begin{verbatim}
(1) func()

(2) func([arg0], [arg1], [argN])

(3) func(
        [arg0], [arg1]
        ,[arg2]
    )
\end{verbatim}        
\end{figure}\label{lst:lecsic}

\section{Значения и типы}\label{sec:types}

\section{Идентификаторы}

\section{Возвращаемые значения}

\section{Порядок выполнения}\label{sec:execrules} 
В основу выполнения команд динамического языка лежит простая концепция -- выполнение функций должно происходить по слоям из самого глубокого вложенной функции к корневому элементу, при этом функция не может быть выполнена, пока не выполнены все ее дочерние элементы.

Пример

Время шло и бизнес требования развития динамических форм внесли свои коррективы, а именно потребовалась реализация асинхронных методов, каждый из которых мог бы выполняться в отдельном потоке или эмулировать выполнение, что потребовало серьезных изменений в структуре разбора и выполнения функций.

Итак поэтапно разберем последовательность действий происходящих при парсинге команд:
\begin{enumerate}
    \item Исходный строковый вид команды передается на вход анализатору, который содержит в себе регулярные выражения для парсинга
    \item Происходит валидация кода(в первых версиях реализации валидации не было), в случае ошибки валидации -- ошибки в количестве параметров функции, скобочках или невозможных символах - команда не будет выполнена и в лог действий будет выведена ошибка «компиляции» валидации
    \item Если команда успешно провалидирована, начнется построение динамического дерева(\gls{dyntree}). Важно отметить, что в ходе выполнения команды, дерево может менять свою структуру(\hyperref[sec:fif]{команда if}), а иногда даже создавать копии самого себя(\hyperref[sec:fcall]{CALL}). 
    \item Для построения динамического дерева(не бинарное дерево \gls{bintree}) используется стандартный левосторонний обход, когда каждая следующая функция последовательно добавляется и спускается вглубь к следующему дочернему узлу, обойдя все элементы у первого дочернего узла, переходит ко второму, третьему и т.д.
    \item ПРИМЕЧАНИЕ. Особенными для разбора считаются функция IF, CALL и STRING в частности CALL и STRING останавливают дальнейший парсинг дочерних узлов функции и выставляют в результат строковое представление аргументов функции. Условная функция(оператор) IF - разбирает изначально только первый дочерний узел, оставшиеся два так же сохраняет в строковых представлениях
    \item После разбора команды в динамическое дерево можно запускать ее на исполнение 
    \item В изначальной реализации динамического языка - динамическое дерево полностью преобразовывалось в очередь и выполняло все команды последовательно по кругу пока все функции не будут выполнены, в более современной реализации очередь содержит только активные элементы выполняющиеся непосредственно в текущей итерации и последовательно добавляет родительские узлы непосредственно в тот момент, когда имеется возможность их выполнить, напомним, что родительский узел может быть выполнен только в случае когда все его дочерние команды вернули результат
    \item Выполнение начинается с самого глубокого уровня, если представить исходное динамическое дерево, то визуально его необходимо перевернуть и по слоям начать выполнять узлы дерева от листьев к корню, каждый следующий слой ожидает выполнения дочерних узлов предыдущего, в случае если функция является асинхронной, она не блокирует выполнение остальных команд на уровне
    \item ОСОБЕННОСТИ. Функции CALL и IF являются функциями модифицирующими динамическое дерево. Так функция CALL создает локальную копию поддерева их своих аргументов при этому есть два варианта(\hyperref[sec:fcall]{CALL})
    \item Функция IF на основе результата первого дочернего узла добавляет в исходное динамическое дерево либо второй, либо третий аргумент функции(третий может отсутствовать), происходит парсинг необходимой команды и динамическое дерево расширяется узлами дочерней функции внутри IF, параллельно выполняющейся в очереди начиная с уровня на котором размещен узел с IF(\hyperref[sec:fif]{подробнее про IF})
    \item В случае возникновения ошибок, возможны ситуации, которые прерывают дальнейшее выполнение команды.
    \item Результат корневого узла дерева обычно не используется и ничего не возвращает, за исключением  использование команды CALL.
\end{enumerate}

Понимая концепции порядка выполнения команд, а также особенности запуска циклов обработки команд можно писать сколько угодно сложные программные решения над динамическими формами.

\section{Функция call}\label{sec:fcall}
    Если результат выполнения команды внутри CALL является динамической функцией создается дерево(\hyperref[sec:execrules]{Порядок выполнения}) если результат не является динамической функцией - исходная команда внутри CALL. Выполняется над другим элементом динамической формы указанным во втором параметре функции CALL

\section{Операторы ветвления}\label{sec:fif}

\section{Циклы}\label{sec:loops}

    Вооружившись ранее изученным набором команд, вам не составит труда реализовать цикл на динамическом языке.
    
    Напишем программу, которая выведет в поле <<Результат>> 100 точек:
    
    Добавьте  на динамическую форму скрытое поле с 'id' : 'counter'. Это поле будет служить счетчиком цикла.
    
    Ниже приведен полный листинг программы:
    
    \begin{verbatim}
    if(
        [isnotin([getValue([counter])],[100])],
        [run(
            [setValue(
                [plus(
                    [getValue([result])],
                    [.]
                )],
                [result]
            )],
            [setValue(
                [plus(
                    [getValue([counter])],
                    [1]
                )],
                [counter]
            )],
            [call(
                [getValue([cmd])],
                [this]
            )]
        )]
    )]
    \end{verbatim}
    
    Запустив программу, можно убедиться, что в поле <<Результат>> вывелось ровно 100 точек.
    
    Теперь рассмотрим принцип работы программы подробнее:
    
    \begin{verbatim}
    if(
        [isnotin([getValue([counter])],[100])],
    \end{verbatim}
    
    В данном фрагменте кода мы проверяем, не выполняется ли условие неравенства нашего счетчика значению 100.
    
    В этом случае выполняем тело цикла, состоящее из 3-x команд внутри блока <<run>>:
    
    \begin{verbatim}
    setValue([plus([getValue([result])],[.])],[result])
    \end{verbatim}
    
    Здесь происходит добавление новой точки в поле с результатом.
    
    \begin{verbatim}
    setValue([plus([getValue([counter])],[1])],[counter])
    \end{verbatim}
    
    Увеличиваем значение счетчика на 1.
    
    \begin{verbatim}
    call([getValue([cmd])],[this])
    \end{verbatim}
    
    И, главная часть, обеспечивающая зацикливание нашей программы - вызываем повторное выполнение скрипта при помощи функции
    <<Call>>
    
\section{Упражнения}
    
    Откройте шаблон <<Исполнятор>> и решите следующие задачи:
    
    \begin{enumerate}
    \item Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz»
    
    \end{enumerate}
\end{document}